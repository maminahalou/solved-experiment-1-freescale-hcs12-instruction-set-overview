Download Link: https://assignmentchef.com/product/solved-experiment-1-freescale-hcs12-instruction-set-overview
<br>
Experiment 1: Freescale HC(S)12 Instruction Set OverviewInstructional Objectives:· To learn how to use your Freescale M68DKIT912C32 Microcontroller Kit· To learn how to use HC(S)12 instructions and addressing modesReferences:· S12CPUv2 Reference Manual, Sections 2, 3, 5, and Appendix A (on References page)· CPU12 Reference Guide (on References page)· Using Your M68DKIT912C32 Microcontroller Kit (on References page)· M68DKIT912C32 Quick Start Guide (on References page)Pre-lab Preparation:· Complete the pre-lab exercises and have them available to check off when your lab beginsIntroduction:Chapter 3 of the preliminary text provides an introduction to the architectural and programmingmodel of the “target” microcontroller that will be used in all the laboratory exercises: theFreescale HC(S)12. As you go through this lab, you will see many similarities between theHC(S)12 and the simple computer covered in ECE 270) – for example, the bus structure,program counter, stack operation, subroutine linkage mechanism, and the actual machineinstructions themselves (LDA, STA, ADD, AND, etc.). As you might guess, though, theHC(S)12 has many more capabilities than our “home grown” simple computer: its instruction setis much more powerful, it has several additional registers, its data types are more diverse, and itsaddressing modes are more extensive. The purpose of this lab, then, is to introduce you to thebasic features and characteristics a “real” microprocessor generally possesses.A clear understanding of a machine’s instruction set (the “tools in the toolbox”) is essential tosuccessful assembly language programming. The primary objective of this laboratory exercise istherefore to provide practical experience with the HC(S)12 instruction set and its plethora ofaddressing modes – material that is covered in Chapter 3 of the text. To accomplish this goal,you will complete a number of exercises dealing with commonly-used HC(S)12 instructions andaddressing modes. Using your Microcontroller Kit, you will execute the code segments youhave written with appropriate test data you have chosen. This will help reinforce yourunderstanding of how instructions and data are stored in memory, plus help prepare you forfuture debugging of more complex programs.In this experiment you will examine representative instructions from the following generalgroups: data transfer, arithmetic, and logical. There will be a number of short exercises forwhich you will be asked to write a code segment and assemble the statements into machine code.For each exercise, you will also pick appropriate test data and perform any memory and/orregister initializations necessary to carry out the exercise. You will then execute the codesegments on your Microcontroller Kit, and record the results of the execution in the providedtables. The primary objectives of these exercises are to: (a) enhance your understanding of howinstructions and data are stored in memory, (b) provide practice in determining meaningful testdata, (c) provide practice in examining the results of instruction execution, and (d) help prepareyou for future debugging of more complex program.ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -2- © 2013 by D. G. MeyerPre-lab:The pre-lab exercises for this experiment address how assembly language mnemonics aretranslated to/from machine (or “object”) code – processes referred to as program assembly anddisassembly. These processes can be performed either “by hand” or by using a softwaredevelopment tool called an Integrated Development Environment (IDE).Hand Assembly ExampleWhile not something you would want to do every day, the process of “hand-assembling” aprogram provides insights concerning how instructions are encoded and stored in memory; also,it provides you with a much greater appreciation of all the tedious work the IDE does for you ina matter of microseconds! The following short program will load the A and B accumulators with8-bit unsigned integer operands and multiply them to produce a 16-bit result. A description ofeach step in the hand-assembly process is provided below.Addr [~] Obj Code Line No. Assembly Mnemonics0800 1 org $8000800 [02] CE0900 2 start ldx #opands0803 [03] A630 3 ldaa 1,x+0805 [03] E600 4 ldab 0,x0807 [03] 12 5 mul0808 [03] 7C0902 6 std prod080B [09] 183E 7 stop80900 9 org $9000900 04 10 opands fcb 40901 03 11 fcb 30902 12 prod rmb 20904 13 endStep-by-Step Description of Hand-Assembly for Example Program(1) The ORG pseudo-op simply tells the assembler that the next opcode byte or data byteshould be placed at the address indicated by the ORG statement. Also, the label “start” isassigned the value $800. Note that no “object code” is assembled for this statement!(2) The opcode for the first instruction – “LDX”– can be found by examining either page 13 ofthe CPU12 Reference Guide or Table A-1 of the S12CPUv2 Reference Manual. Sinceimmediate addressing mode is used (as indicated by “#”), the opcode is CEh. But because“opands” is a forward reference, we can not as of yet determine the two-byte value (here,an address) which should be placed following this opcode. On the “first pass” of theassembly process we will therefore reserve the requisite two bytes and mark “opands” as anundefined symbol. As the “first pass” of the assembly proceeds, all labels/symbols used inthe program should be assigned a value; to keep track of all the symbols used in a programand their assigned values, a symbol table is utilized. Once the “first pass” is complete (andeach entry in the symbol table is assigned a value), a “second pass” is used to “fill in theblanks” – i.e., to fill in the forward reference values which were left unassigned during the“first pass” of the assembly process. At this point, then, our symbol table is as follows:ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -3- © 2013 by D. G. MeyerSYMBOL VALUEstart $800opands &lt;undefined&gt;(3) Because three bytes were reserved for the previous instruction (“LDX”), the opcode of thenext instruction – “LDAA” – will be stored at location $803. Since an indexed addressingmode is used, the opcode is A6h and a “postbyte” must be included following the opcode toindicate the particular type of indexed addressing mode used. The format of the requisitepostbyte can be determined using the “Indexed Addressing Mode Postbyte Encoding” tableon page 21 of the Guide or in Table A-3 of the Manual; here we find the postbyte should be$30 (the actual encoding scheme used to derive this can be found on page 22 of the Guideor in Table A-4 of the Manual).(4) Since two bytes of program memory were consumed by the previous instruction(“LDAA”), the opcode of the next instruction – “LDAB” – will be stored at location 0805h.Since an indexed addressing mode is used, the opcode is $E6 and a “postbyte” must beincluded following the opcode. Using a procedure similar to that described above, a postbyte of $00 is obtained.(5) Since two bytes were consumed by the previous instruction (“LDAB”), the opcode of thenext instruction – “MUL” – will be stored at location $0807. The opcode for this singlebyteinstruction is $12.(6) The next instruction, located at $808, will store the double-byte result obtained in a pair ofconsecutive memory locations (in “big endian” format, i.e., high order byte first). Here,extended addressing mode is used; the symbol that identifies the storage location address is“prod” – again, a forward reference. We must therefore reserve two bytes following the“STD” opcode ($7C) to store the 16-bit value associated with the symbol “prod”. Oursymbol table is now as follows:SYMBOL VALUEstart $800opands &lt;undefined&gt;prod &lt;undefined&gt;(7) The final instruction, “STOP” (a two-byte instruction stored at locations $80B and $80C),halts the execution of the processor (we will use STOP instructions as a “placeholder” forsetting breakpoints – in practice, this instruction does not actually “stop” the processorwhen operating it in background debug mode).ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -4- © 2013 by D. G. Meyer(8) Following an “ORG” at location $900 to establish the location of the operand and resultdata, the next line of assembly code uses the “FCB” (form constant byte) psuedo-op toassign an initial value to the memory location indicated when the object code isdownloaded into the target system’s memory. The address at which this constant byte is tobe stored is $900. Also, since the label “opands” is associated with this statement, it is nowassigned the value $900. Our symbol table is correspondingly modified as follows:SYMBOL VALUEstart $800opands $900prod &lt;undefined&gt;(9) On the next line line, an “FCB” pseudo-op is used to initialize the second operand, locatedat $901.(10) At location $902, an “RMB” (reserve memory block) pseudo-op is used to reserve twobytes of memory for storing the result. Note that these locations are NOT initialized whenthe object file is downloaded into the target system’s memory. Also, the symbol “prod” isencountered and assigned the value $902. Our symbol table is correspondingly modified asfollows:SYMBOL VALUEstart $800opands $900prod $902(11) The “END” pseudo-op indicates the source file is complete – note that no object code isassembled for this statement! We are not finished yet, however, because on the “first pass”we left some forward references undefined (in the “partially assembled” code). Thus, a“second pass” (i.e., second scan over the partially assembled source file) is necessary to“fill in” the previously undefined forward references.Question: What if the symbol table still has some undefined entries at the end of the“first pass”? Will the “second pass” be successfully completed?Answer: __________________________________________________________________________________________________________________________ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -5- © 2013 by D. G. MeyerAddress Object Code Assembly Instructionsbcdb org $800 ; BCD to Binary Conversion Program_____ ___ ___ ___ ldaa bcdin ; (A) ¬ packed BCD input data_____ ___ ___ ___ anda #$f0 ; mask off lower nibble; =&gt; (A) = 16 * (upper nibble)_____ ___ ___ ___ lsra_____ ___ ___ ___ tfr a,b ; (B) = 8 * (upper nibble)_____ ___ ___ ___ lsra_____ ___ ___ ___ lsra ; (A) = 2 * (upper nibble)_____ ___ ___ ___ psha ; store temporarily on stack_____ ___ ___ ___ addb 1,sp+ ; (B) = (2 + 8) * (upper nibble)_____ ___ ___ ___ ldaa bcdin ; reload initial BCD data_____ ___ ___ ___ anda #$0f ; mask off upper nibble_____ ___ ___ ___ psha ; store temporarily on stack_____ ___ ___ ___ addb 1,sp+ ; (B) = 10 * (un) + (ln)_____ ___ ___ ___ stab binout ; store converted binary value_____ ___ ___ ___ stop_____ ___ ___ ___ bcdin fcb $34 ; BCD input data_____ ___ ___ ___ binout rmb 1 ; location to store converted binary_____ ___ ___ ___ endSymbol Table:Pre-lab Exercise 1: The following program takes the BCD number located at the memorylocation “bcdin”, converts it to its binary equivalent, then stores the converted value at thememory location “binout”. For example, if the BCD number “10” was stored at “bcdin”, itwould be converted to the binary number “00001010” (which equals 0Ah), and store it at“binout”. Hand-assemble this BCD-to-binary (bcdb) program and complete the symbol table.ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -6- © 2013 by D. G. MeyerHand Disassembly ExampleAs one might guess, program disassembly is just the inverse of program assembly – only less funto do on a regular basis. Unfortunately, however, it is sometimes necessary when trying todebug a system based on a “memory dump.” For the purpose of illustration, the followingexample program (that performs BCD subtraction) will be disassembled step by step.Address Contents Disassembled Instruction0900 CE ldx #$90C0901 090902 0C0903 89 adca #00904 000905 A0 suba 1,x+0906 300907 AB adda 0,x0908 000909 18 daa090A 07090B 18 stop090C 3E090D 34 data090E 49 dataStep-By-Step Description of Disassembly For Example Program(1) Using the numerically-listed S12CPU Opcode Map (Page 28 of the Guide or Table A-2 ofthe Manual) as a reference, opcode ($CE) – stored at location $900 – is an “LDX”instruction using immediate addressing mode. The two data bytes, immediately followingthe opcode, are $09 and $0C.(2) The next opcode ($89), stored at location $903, is an “ADCA” instruction using immediateaddressing mode. The single data byte, immediately following the opcode, is $00.(3) The next opcode ($A0), stored at location $905, is a “SUBA” instruction using some formof indexed addressing mode. The post byte ($30) following the opcode indicates theparticular form of indexed addressing utilized; using page 21 of the Guide or Table A-3 ofthe Manual as a guide, the particular form of indexed addressing is found to be “auto postincrementby one” with “X” as the index register.(4) The next opcode ($AB), stored at location $907, is an “ADDA” instruction using someform of indexed addressing mode. The requisite post byte (here, $00) is translated as in (3),above, into “zero offset indexed” with “X” as the index register.(5) The next opcode ($18), stored at location $909, references “page 2” of the Opcode Map;this tells us that more than one byte is used to represent the machine code for the instructionstored here. The second opcode byte ($07), combined with the first, indicates that this isthe “DAA” instruction.(6) The final opcode ($183E), stored at locations $90B and $90C, is the “STOP” instruction.(7) The remaining two bytes, stored at locations $90D and $090E, represent data used by theprogram.ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -7- © 2013 by D. G. MeyerAddress Contents Disassembled Instruction0900 860901 170902 8B0903 D30904 180905 070906 C60907 840908 370909 AB090A 80090B 18090C 07090D 86090E 19090F A00910 B00911 180912 070913 180914 3EExecution Step (PC) (A) (B) CCR bits setInitial Values 0900 00 00 –After Single Step 1After Single Step 2After Single Step 3After Single Step 4After Single Step 5After Single Step 6After Single Step 7After Single Step 8After Single Step 9After Single Step 10Pre-lab Exercise 2. Disassemble the HC(S)12 machine code listed below and “single step”through it by hand, completing the chart below. Write the disassembled instructions underthe Disassembled Instruction heading, clearly indicating the instructions associated withthe specific memory contents. Each “step” refers to the execution of one instruction.Assume the first opcode byte is at location $900, and that all CCR bits are initially cleared.ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -8- © 2013 by D. G. MeyerCode Warrior TutorialCodeWarrior is the integrated development environment (IDE), which we will use to edit, load,and debug our code. This is a quick tutorial that will give you an introduction to the tools wewill be using for the duration of the semester.Start CodeWarrior on the lab computers as follows:Start &gt; Programs &gt; ECE Software &gt; CodeWarrior IDEWhen the Startup window comes up, select Create New Project.When the New Project window appears, select:HCS12 &gt; HCS12C Family &gt; MC9S12C32In the right window, select P&amp;E Multilink/Cyclone Pro. When finished, press Next. Deselectthe check by C and select Absolute Assembly. Press Finish.In the left frame, double-click main.asm to open the assembly source file. You will edit thecontents of this file later, but for the purposes of this tutorial, you can leave the preloadedprogram as it is.Now, click the Debug button ( ) to start the debugger. The window shown below will pop up.Make sure that the Connection and Interface Type drop-down box has BDM Multilink orCable 12 – USB Port selected to connect to the BDM on the USB port.Click Connect. An update message may appear; wait until it is done, and it will proceedautomatically.ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -9- © 2013 by D. G. MeyerThis is the debugger window, which you will use to run and debug your code.The Source window is where you can view the progress of your program’s execution. Eachtime you start ( ) or single step ( ), you will notice that a new line will be highlighted in thesource window. The highlighted line is the next instruction to be run.If you want to set a Breakpoint in your code, you can right-click the line in the source windowand select Set Breakpoint. This means that when the debugger encounters this address, it willhalt the processor before running that instruction. Get comfortable with this feature and use thisoften when debugging code. It will also come in handy if you want to run a set of instructionsand stop before running another. You can delete a breakpoint by right-clicking again andselecting Delete Breakpoint.The Assembly window allows you to view memory as a sequence of disassembled instructions.Be careful though: this does not mean that any given address contains data that was meant to beinterpreted as instruction. For example, a value in memory of $FF (0xFF) will be interpreted asan LDS instruction, even if this data wasn’t meant to be an instruction.Note: Hexadecimal numbers will sometimes be notated by a “0x” or “$” prefix or an “h” suffix.For example, you might see 2016 written either as “0x20”, “$20” or “20h”. It should also benoted that CodeWarrior will only allow the “$” notation for hex numbers in your code.ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -10- © 2013 by D. G. MeyerThe Memory window allows you to view and edit the contents of memory (Note: All of thevalues are displayed in hexadecimal format). You can view a specific address by right-clickinginside the window, selecting Address, entering the address in the text box, and pressing Okay.The leftmost number in each row is the base address for that row.Each grouping of two hexadecimal digits located to the right of the row base address is a byte ofdata in memory. The address of each byte of data corresponds to the row base address plus thezero-based column number. For example, in the above figure, the first row base address is $800(0x0800). The first column corresponds to address $800 (0x0800) and contains data $00 (0x00);the second column corresponds to address $801 (0x0801) and contains data $11 (0x11); etc.If you double-click a given byte of data, it will become highlighted, and you can edit it. Onceyou edit the data, if the address of the data you changed is also visible in the Assembly window,you will see it update as well.The Register window contains the values of the various registers on the microcontroller. To editany register’s value, you can double-click on it and enter a new value. To toggle any value in theCCR (condition code register), you can double-click on the letter of the bit you want to change.If you modify the value in the PC (program counter) register, you will change the address of thenext instruction your microcontroller will execute.ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -11- © 2013 by D. G. MeyerIf you have any variables in your code, you can watch them by right-clicking in the Datawindow, clicking on Add Expression…, and typing in the variable name. Make sure that youalso change Mode under the right-click menu to Periodical. Enter “1” into the text box for thefastest data refresh rate. (This will allow the values to automatically update.)To examine the effect of executing code segments using the development environment in lab,use the following “generic” assembly source file for each test case:; Generic assembly source file for testing code segmentsorg $800 ; location $800 is the beginning of SRAMldaa opand1 ; load first operandoraa opand2 ; instruction(s) being tested (with second operand)staa result ; store resultstop ; SET BREAKPOINT HEREorg $900 ; place operand data at location $900opand1 fcb $CC ; test dataopand2 fcb $55 ; test dataresult fcb 0 ; place to store result (initially cleared)endLoading this code into the debugger should yield the following (after setting PC to $800 andclearing the other registers). If your code is not displayed in the source window after you changethe PC, press the single step button, change the PC back to $800 and re-clear the registers.ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -12- © 2013 by D. G. MeyerAt this point, you can either “single step” ( ) through the code or “Start” ( ) to execute thecode up to a “breakpoint”. (A convenient place to set a breakpoint is the STOP instruction.) Thememory and register values will change as the code executes. Note that the assembly windowcan be used to display the machine code as it is stored in memory, while the data and memorywindows can be used to monitor how memory locations are being modified as the code executes.After execution of the code segment is complete, the debugger display should be as follows:Note that the value $DD (0xDD) has been written to memory location $902 (0x0902, “result”),that the A register also (still) contains the value $$DD (0xDD), that the Negative Flag (N) hasbeen set by virtue of the result generated, and that the Zero Flag (Z) remains cleared.Negative flag set (bold)ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -13- © 2013 by D. G. MeyerExperimental ProcedureYou are to write and assemble the instruction sequence requested for each exercise that follows.You must also choose appropriate test data, and show initialization data for any memorylocations and/or registers necessary to perform the exercise. Note that test and initialization datais to be placed in the before execution boxes of each table. In addition, no memory locations orregisters you choose as relevant should be left as don’t cares. If no memory locations arerequired to perform a particular exercise, write “NONE” in the before execution box underrelevant memory. The following sample exercise illustrates how a table should be completed.SAMPLE EXERCISE: “ORAA” instruction using extended addressing mode.Assembly Instruction(s) Machine Code Relevant Memory Relevant RegistersORAA $900Effective Address:$900BA 09 00 Before execution:(0900) = 55Before execution:(A) = CCN = 0, Z = 1After execution: After execution:In the table above, memory location $900, along with the test data $55 and $CC, have beenchosen arbitrarily. However, note that the chosen memory locations reside in user memoryspace, and that $55 and $CC are meaningful test data (i.e., ORing $55 and $CC tests all possiblebit combinations and produces a change in the A register and flags which will clearly indicate thecode segment works.)You will then execute your code segments on the Microcontroller Kit (after having initializedany relevant memory locations and/or registers). Execution results will then be recorded in theafter execution boxes provided in the tables. For example, after executing the ORAA instructiongiven above, the sample exercise table would be completed (based on memory and registerobservations) as shown below.SAMPLE EXERICSE: “ORAA” instruction using extended addressing mode.Assembly Instruction(s) Machine Code Relevant Memory Relevant RegistersORAA $900Effective Address:$900BA 09 00 Before execution:(0900) = 55Before execution:(A) = CCN = 0, Z =1After execution:(0900) = 55After execution:(A) = DDN = 1, Z = 0Note that the effective address for this example is $900, since extended addressing mode wasused. Note also that if you choose to put your data at $900, you will need to place your code atdifferent memory locations – a suggested location would be $800.ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -14- © 2013 by D. G. MeyerStep 1: Learning the ToolsUsing the generic test file described under Experimental Procedure (available on the coursewebsite), verify that you get the same results as given for the SAMPLE EXERCISE.Demonstrate to your lab instructor that you can assemble a source file, load the assembledmachine code into the target system using the debugger, trace through the code execution, anddocument the results obtained from executing the code sequence.Step 2: Verification of Hand Assembly Using the Microcontroller KitEnter the machine code from Pre-lab Exercise 1 using the memory window in the debugger.Execute the program to verify its operation. Try two additional values for bcdin by modifyingthe location in which it is stored, and record the “after execution” results found in memorylocation binout. Explain what happens if “illegal” (i.e., non-BCD) data is used – try it!Step 3: Verification of Hand Disassembly Using the Microcontroller KitEnter the machine code from Pre-lab Exercise 2 using the memory window in the debugger.Store the opcodes beginning at location $900, initialize (A) to 0, (B) to 0, (SP) to $C00, (PC) to$900, and the condition code (CCR) register to 0 (i.e., all flags cleared). Then, single stepthrough the program to verify its operation and fill out the table below. Compare these results tothe values you “predicted” when you completed Prelab Exercise 2.Execution Step (PC) (A) (B) CCR bits setInitial Values 0900 00 00 –After Single Step 1After Single Step 2After Single Step 3After Single Step 4After Single Step 5After Single Step 6After Single Step 7After Single Step 8After Single Step 9After Single Step 10Explanation: ________________________________________________________________________________________________________________________________ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -15- © 2013 by D. G. MeyerStep 4: Exploring Addressing ModesUsing the ADDA instruction, you are going to explore the various addressing modes. For eachaddressing mode, write the instruction in the appropriate format, and assemble the instruction.You must also choose appropriate test data, and show initialization data for any memorylocations and/or registers necessary to perform the exercise. Note that test and initialization datais to be placed in the before execution boxes of each table. In addition, no memory locations orregisters you choose as relevant should be left as don’t cares. If no memory locations arerequired to perform a particular exercise, write “NONE” in the before execution box underrelevant memory.Step 4-A: “ADDA” instruction using immediate addressing mode.Step 4-B: “ADDA” instruction using extended addressing mode.Assembly Instruction Machine Code Relevant Memory Relevant RegistersEffective addr:Before execution: Before execution:After execution: After execution:AssemblyInstruction(s)Machine Code Relevant Memory Relevant RegistersEffective addr:Before execution: Before execution:After execution: After execution:ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -16- © 2013 by D. G. MeyerStep 4-C: “ADDA” instruction using Indexed with 5-bit Constant Offset addressing mode.Step 4-D: “ADDA” instruction using Indexed with 8-bit Constant Offset addressing mode.Step 4-E: “ADDA” instruction using Indexed with 16-bit Constant Offset addressing mode.AssemblyInstruction(s)Machine Code Relevant Memory Relevant RegistersEffective addr:Before execution: Before execution:After execution: After execution:AssemblyInstruction(s)Machine Code Relevant Memory Relevant RegistersEffective addr:Before execution: Before execution:After execution: After execution:AssemblyInstruction(s)Machine Code Relevant Memory Relevant RegistersEffective addr:Before execution: Before execution:After execution: After execution:ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -17- © 2013 by D. G. MeyerStep 4-F: “ADDA” instruction using Indexed with Accumulator Offset addressing mode.Step 4-G: “ADDA” instruction using Indexed with Auto Post-Increment addressing mode.Step 4-H: “ADDA” instruction using Indexed-Indirect with Constant Offset addressing mode.AssemblyInstruction(s)Machine Code Relevant Memory Relevant RegistersEffective addr:Before execution: Before execution:After execution: After execution:AssemblyInstruction(s)Machine Code Relevant Memory Relevant RegistersEffective addr:Before execution: Before execution:After execution: After execution:AssemblyInstruction(s)Machine Code Relevant Memory Relevant RegistersEffective addr:Before execution: Before execution:After execution: After execution:ECE 362 – Experiment 1 Rev 08/13Bigger Bytes Lab Manual -18- © 2013 by D. G. MeyerStep 4-I: “ADDA” instruction using Indexed-Indirect with Accumulator Offset addressingmode.Assembly Instruction(s) Machine Code Relevant Memory Relevant RegistersEffective addr:Before execution: Before execution:After execution: After execution: